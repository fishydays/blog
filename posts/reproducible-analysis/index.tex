% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrartcl}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother


\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother

\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage{bookmark}

\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Reproducibility in Data Analysis: A Comparative Perspective on Virtual Environments and Containers},
  pdfauthor={Elaine Chu},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{Reproducibility in Data Analysis: A Comparative Perspective on
Virtual Environments and Containers}
\author{Elaine Chu}
\date{2025-01-18}

\begin{document}
\maketitle


Imagine you are a master chef who just developed the best recipe for
chicken adobo. You can't wait to share this recipe with the rest of the
world so they can recreate the dish themselves. How would you go about
ensuring others can replicate the dish exactly as you did? Would just
providing the recipe be enough? Different kitchens may have different
cookware available, and ingredients may differ slightly depending on the
country. So just providing the recipe itself may not suffice.

\includegraphics{chef.gif}

This is a similar question that is faced by data scientists after they
created a model and want to share the results of their analysis with
others. In data analysis, reproducibility is a cornerstone of credible
and reliable work. It ensures others can recreate an analysis and verify
its results, fostering trust in the insights derived from the data.
However, to achieve this, just providing the code of the analysis is
insufficient. We often need to ensure that the differences in computer
environments are also addressed so that the analysis can run other
computers without any issue. We want to not only have the code for
analysis to be reproducible, but the entire computational environment to
also be reproducible. There are several tools such as
\texttt{environment.yaml} files, conda lock files, and docker containers
that can help us do exactly that. Each of these tools offers a different
level of precision and isolation, much like providing varying degrees of
guidance to recreate a dish by a chef. Now let's explore each of them in
detail!

\subsubsection{Environment.yaml Files: The recipe and
ingredients}\label{environment.yaml-files-the-recipe-and-ingredients}

One way to reproduce a computational environment is by using an
\texttt{environment.yaml} file. Computers can create a virtual
environment in their system. Virtual environment is an isolated
workspace that allows us to manage and run specific packages and
programs without affecting the global environment of the computer. An
\texttt{environment.yaml} file will provide instructions to create a new
virtual environment with the specific packages needed to reproduce the
analysis listed.

This is like the chef sharing the recipe along with a list of
ingredients to others. It provides essentials on what is needed to
recreate the dish, but it also assumes other people can source the
ingredients and figure out the appropriate cookware for it. Similarly,
although \texttt{environment.yaml} files lists the necessary packages,
it does not specify the exact version or provide information on what
dependents those packages may have. Every time someone install an
environment using the \texttt{environment.yaml} file, it needs to run a
solver to figure out which version of the package to install and what
are the dependent packages it needs. This could introduce variability
and inefficiencies. Is there a way we can overcome this? Enter conda
lock files\ldots{}

\subsubsection{Conda Lock Files: A Precise shopping
list}\label{conda-lock-files-a-precise-shopping-list}

Conda lock files are similar to \texttt{environment.yaml} files where it
gives instructions on how to create a new virtual environment. However,
it also includes detailed information on the specific versions of the
packages and all the dependent packages are needed. This eliminates the
need to run a solver every time someone installs the environment using
the conda lock file. This ensures the environment is recreated exactly
as specified, ensuring consistency and reducing setup time.

This is similar to the chef giving a precise shopping list of
ingredients with the specific brands, quantities, and version listed
along with cookware requirements. This minimizes variability and ensures
others can recreate the dish as exactly as intended. The added precision
does, however, make the conda lock files more complex to create and use
when compared to an \texttt{environment.yaml} file.

Both \texttt{environment.yaml} files and conda lock files create virtual
environments, however, sometimes just a virtual environment is not
enough. Outside of the programming language and packages used in the
analysis, there could be other computer specifications like operating
systems or hardware configurations that are needed for the analysis to
run. How do we go one step further and address these differences? We can
use docker containers\ldots{}

\subsubsection{Docker Containers: A Fully Equipped
Kitchen}\label{docker-containers-a-fully-equipped-kitchen}

Instead of just creating a virtual environment, docker creates a
containerized environment. Essentially, it splits up the resource in a
computer system itself so it can run in complete isolation. Examples of
elements it splits on could be storage devices, network resources, and
other hardware capacities. The container will include not only the
necessary programming language and packages, but also the operating
system and system-level dependencies required for the analysis.

Back to the analogy of the chef, this is like providing a fully equipped
and pre-stocked kitchen. All the ingredients and tools you need to make
the dish are there without needing to assemble or install anything else.
This level of completeness ensures the analysis can be reproduced
without any issue. However, docker containers require more expertise to
set up and manage, they are heavier and more resource intensive.

\subsubsection{Choosing the right tool}\label{choosing-the-right-tool}

The choice between \texttt{environment.yaml} files, conda lock files,
and Docker containers really depends on the specific requirements of the
data analysis project at hand. If it is a project where minor variations
in package versions do not matter, then \texttt{environment.yaml} files
may be ideal. It is simple and easy to create and share. If we want to
have a stricter requirement for package version and dependencies, then
conda lock files will be our choice. Although slightly more complex than
\texttt{environment.yaml} files, they are ideal for projects that
require precise reproducibility. Finally, if we want a fully
self-contained and portable solution for long-term reproducibility for
complex projects, docker containers may be the tool we need. They will
require more resources and expertise to use, however, they also offer
the highest level of reproducibility and isolation.

By understanding the trade-offs between these different tools allows
data scientists to choose the right tool for their project's needs.
Whether it is sharing a recipe, a precise shopping list, or a full
equipped kitchen, each approach offers a unique pathway to reproducible
and reliable analysis.




\end{document}
